**Although the basic idea of binary search is comparative straightforward，the details  can be surpriseingly tricky**

**二分查找的思想很简单，但想要做好二分查找主要是对细节的掌握**



#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```c++
int searchLeft(vector<int>& nums, int target) {
	int left = 0, right = nums.size() - 1;
	while (left <= right) {
		int mid = left + (right - left) / 2;
		if (nums[mid] >= target) {
			right = mid - 1;
		}
		else if(nums[mid] < target){
			left = mid + 1;
		}
	}
	return left;
}

```





**思考：**

- **最终left和right的位置在哪，所代表的又是什么？**

​       最终right-left == -1，left右侧一定大于或大于等于等于target（根据题目要求），right左侧一定小于或小于等于等于target（根据题目要求）

- **如果num[mid] = target时直接输出mid会出现什么bug？**

  如果数组中有相同的数则的得到的位置不一定是第一个要查找的数

- **如果题目要求数组最后一个为target数的下标要做那些变化？**（详细见下题）

  ```c++
  int searchRight(vector<int>& nums, int target) {
  	int left = 0, right = nums.size() - 1;
  	while (left <= right) {
  		int mid = left + (right - left) / 2;
  		if (nums[mid] > target) {    
  			right = mid - 1;
  		}
  		else if(nums[mid] <= target) {
  			left = mid + 1;
  		}
  	}
  	return right;
  }
  ```

  

  

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```c++
int searchLeft(vector<int>& nums, int target) {
	int left = 0, right = nums.size() - 1;
	while (left <= right) {
		int mid = left + (right - left) / 2;
		if (nums[mid] >= target) {
			right = mid - 1;
		}
		else if(nums[mid] < target){
			left = mid + 1;
		}
	}
	return left;
}

//最后的结果left是第一个大于等于target的下标，和STL中的lower_bound的效果有些类似，但lower_bound返回的是第一个大于等于target的指针

int searchRight(vector<int>& nums, int target) {
	int left = 0, right = nums.size() - 1;
	while (left <= right) {
		int mid = left + (right - left) / 2;
		if (nums[mid] > target) {    
			right = mid - 1;
		}
		else if(nums[mid] <= target) {
			left = mid + 1;
		}
	}
	return right;
}

//最后的结果right是最后一个大于等于target的下标，和STL中的upper_bound的效果有些类似，但upper_bound返回的是第一个大于等于target的指针

vector<int> searchRange(vector<int>& nums, int target) {
	int leftborder = searchLeft(nums, target);
	int rightborder = searchRight(nums, target);
	if (rightborder - rightborder == 0) return { -1, -1 };
	else return { leftborder, rightborder };
}
```

查找元素的第一个位置
![IMG_20210729_212117](https://user-images.githubusercontent.com/68804220/127501593-c5f812f5-6aaf-4f82-8402-d0d0f7f90ff8.jpg)


最后一个位置

![image](https://user-images.githubusercontent.com/68804220/127501534-6e540d55-511e-466f-87db-67d6ea9b9fbb.png)
