#### [1953. 你可以工作的最大周数](https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work/)

```c++
long long numberOfWeeks(vector<int>& milestones) {
	long long maxum = *max_element(milestones.begin(), milestones.end());
	long long res = accumulate(milestones.begin(), milestones.end(), 0LL) - maxum;
	if (maxum > res) {
		return 2 * res + 1;
	}
	else {
		return res + maxum;
	}
}
```



**解题思路：**

工作是否能全部完成，取决于两边是否相等。

![1.png](https://pic.leetcode-cn.com/1627803200-fPkPMT-1.png)

而当最大任务数<=剩余任务数时，剩余任务数量可以通过内部相互抵消来减少自身的值直到与最大任务数相等(可以想象剩余任务对应的球可以变小)。
举个例子[1,2,5,6]
最大任务数6
剩余任务数8 ([1,2,5])
可以先完成任务数为1和任务数为2的工作各一次，这样剩余的任务数就减小到6与最大任务数相等，即所有工作都能完成。

![2.png](https://pic.leetcode-cn.com/1627803358-CmuMQe-2.png)





这里有一个问题，剩余任务一定能减少到与最大任务相等么?
(如最大任务为10，其余任务总计为100?)
考虑剩余任务可以减小到的最小值(即球可以缩小到的最小值)
即当剩余任务内部相互抵消到只剩余一种任务或全部都抵消时，便不能再减少，达到最小值。
而对于只剩一种任务时其数量一定小于最大任务数量，即一定能减少到与最大任务数量相等的情况。



**知识加强：**

1):STL相关算法函数：

*max_element：返回⼀个 迭代器 ，指向[ beg , end )中最⼤的元素

accumulate(beg,end,val) ：对[ beg , end )内元素之和，加到初始值 val 上