## **1143. 最长公共子序列**

(https://leetcode-cn.com/problems/longest-common-subsequence/)

 

####  思路：典型的二维动态规划问题

 首先先回顾动态规划问题的解题步骤（五步三想）：

 五步：

1. 确定dp数组（dp table）以及下标的含义

2. 确定递推公式

3. dp数组如何初始化

4. 确定遍历顺序

5. 举例推导dp数组

 

三想：

\-  这道题目我举例推导状态转移公式了么？

\-  我打印dp数组的日志了么？

\-  打印出来了dp数组和我想的一样么

 

解题：

 

1. 确定dp数组（dp table）以及下标的含义：

 

  设字符串 text1和特性t的长度分别为m和n，创建m+1行n+1列的二维数组的dp，其中dp[i][j]表示text1[0:i]和text2[0:j]的最长公共子序列的长度，上述表示中，text1[0:i]和text2[0:j]表示长度为i和j的text1和text2的长度i和j的前缀

 

 2.确定递推公式和初始化

![image-20210726192414473](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210726192414473.png)

`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`

<!--dp[i][j] = d[i-1][j]的情况-->

|    <font  color='red'>j</font>    |   a   |   b   | <font  color='blue'>c</font>（text2的第j个位置） |       |
| :-------------------------------: | :---: | :---: | :----------------------------------------------: | :---: |
| ***<font  color='red'>i</font>*** | **a** | **b** |                      **c**                       | **a** |

<!--dp[i][j] = d[i][j-1]的情况-->

|    <font  color='red'>j</font>    |   a   |   b   |   c   | <font  color='blue'>e</font>（text2的第j个位置） |
| :-------------------------------: | :---: | :---: | :---: | :----------------------------------------------: |
| ***<font  color='red'>i</font>*** | **a** | **b** | **d** |                                                  |



 3.确定遍历顺序并推导dp数组

![image-20210726195601994](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210726195601994.png)

此步骤才是最详细的过程，当递推公式推导不出来时可以先画此图，每个动态规划的题目都可以画出推导过程







代码：

```c++
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            char c1 = text1.charAt(i - 1);
            for (int j = 1; j <= n; j++) {
                char c2 = text2.charAt(j - 1);
                if (c1 == c2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}

```





注意事项：

- 注意这里dp数组有明确的含义的，下标从1开始，下标要区分两个text数组

